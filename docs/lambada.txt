-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Please see the README on GitHub at
--   <a>https://github.com/rudsvar/lambada#readme</a>
@package lambada
@version 0.1.0.0


-- | A module that defines Lambada expressions
module Lambada.Expr

-- | The expression data type
data Expr

-- | Integer
EInt :: Integer -> Expr

-- | String
EStr :: String -> Expr

-- | Variable
Var :: String -> Expr

-- | Let-expression
Let :: String -> Expr -> Expr -> Expr

-- | Lambda abstraction
Abs :: String -> Expr -> Expr

-- | Function application
App :: Expr -> [Expr] -> Expr
instance GHC.Classes.Eq Lambada.Expr.Expr
instance GHC.Show.Show Lambada.Expr.Expr
instance GHC.Num.Num Lambada.Expr.Expr


-- | A module for evaluating expressions in Lambada
module Lambada.Eval

-- | A function that evaluates an expression
evaluate :: Expr -> Either String Expr

-- | A function that evaluates an expression in a given context
eval :: Ctx -> Expr -> Either String Expr

-- | A data type for storing variables and their values
type Ctx = Map String Expr


-- | A module containing the <a>State</a> data type, which is used in
--   Parser.ParseT to represent the changing state while parsing.
module Parser.State

-- | The state data type It keeps track of the remaining input, the
--   location, whether or not input has been consumed, and the error stack.
data State a
State :: a -> Loc -> Bool -> ParseError a -> State a
[inp] :: State a -> a
[loc] :: State a -> Loc
[consumed] :: State a -> Bool
[parseError] :: State a -> ParseError a

-- | A data type used to represent an error while parsing. This is used to
--   generate a trace of what a parser expected, what the parser got, and
--   where the error occured.
data ParseError a
ParseError :: a -> [Label] -> ParseError a
[actual] :: ParseError a -> a
[expected] :: ParseError a -> [Label]

-- | The location data type. This is used to keep track of the location in
--   the <a>State</a> data type.
data Loc

-- | A label used to explain what was expected when the the
--   <a>ParseError</a> occured.
type Label = String

-- | Add an error to the <a>State</a> stack with the given label.
labelState :: Label -> State a -> State a

-- | Generates a state with the given filepath and input.
defaultState :: FilePath -> a -> State a

-- | Function that edits the location of the <a>State</a>
incCol :: State a -> State a

-- | Function that edits the location of the <a>State</a>
incLine :: State a -> State a

-- | Function that edits the location of the <a>State</a>
resetCol :: State a -> State a

-- | Clear the expected list
clearExpected :: State a -> State a

-- | Update the remaining input in the error
updateError :: State a -> State a
instance GHC.Classes.Eq Parser.State.Loc
instance GHC.Show.Show a => GHC.Show.Show (Parser.State.State a)
instance GHC.Show.Show a => GHC.Show.Show (Parser.State.ParseError a)
instance GHC.Show.Show Parser.State.Loc


-- | A module for the <a>Result</a> data type
--   
--   It is very similar to the <a>Either</a> data type, but with some new
--   functions.
module Parser.Result

-- | The result data type, inspired by <a>either</a>, but made into its own
--   type to redefine the show instance.
data Result b a
Err :: (State b) -> Result b a
Ok :: (a, State b) -> Result b a

-- | Check that the result is as expected.
err :: Result b a -> Bool

-- | Check that the result is as expected.
ok :: Result b a -> Bool
instance (GHC.Show.Show b, GHC.Show.Show a) => GHC.Show.Show (Parser.Result.Result b a)
instance GHC.Base.Functor (Parser.Result.Result b)


-- | The most general parser type, along with some low level functions used
--   to manipulate the <a>State</a> of the parser.
module Parser.ParseT

-- | The parser type, which is imply a function from one state to either a
--   state, or a state along with a result.
newtype ParseT b a
P :: (State b -> Result b a) -> ParseT b a
[runParser] :: ParseT b a -> State b -> Result b a

-- | The <a>Functor</a> instance of <a>ParseT</a>, letting you apply a
--   function to the result of a given parser.

-- | The <a>Applicative</a> instance of <a>ParseT</a>, giving us the
--   <a>pure</a> function, which always succeeds with the input as the
--   result, and the <a>&lt;*&gt;</a> operator, which lets you get a
--   function as a result from one parser, and then apply it to the second.

-- | The <a>Alternative</a> instance of <a>ParseT</a>, giving us two
--   parsers. The first is the <a>empty</a> parser which always fails. The
--   second is the <a>&lt;|&gt;</a> operator, which first parses with the
--   first argument, and if it fails without consuming any input, parses
--   with the second.

-- | The <a>Monad</a> instance of the <a>ParseT</a>, which gives you the
--   <a>return</a> function, which is defined equal to <a>pure</a>, and the
--   <a>&gt;&gt;=</a> (bind) operator, which parses with the first input,
--   and sends the result (if it succeeds) to the function that is the
--   second input.

-- | A parser that applies the given function to its state.
modifyState :: (State b -> State b) -> ParseT b ()

-- | A parser that returns its state.
getState :: ParseT b (State b)

-- | A parser that replaces its state with a given one.
setState :: State b -> ParseT b ()
instance GHC.Base.Functor (Parser.ParseT.ParseT b)
instance GHC.Base.Applicative (Parser.ParseT.ParseT b)
instance GHC.Base.Alternative (Parser.ParseT.ParseT b)
instance GHC.Base.Monad (Parser.ParseT.ParseT b)
instance GHC.Base.MonadPlus (Parser.ParseT.ParseT b)


-- | A module defining a few primitive, general parsers. These can be used
--   for any kind of input.
module Parser.Prim

-- | Label a parser for better error messages
label :: String -> ParseT b a -> ParseT b a

-- | The same as <a>label</a>, but with the arguments flipped
(<?>) :: ParseT b a -> String -> ParseT b a
infixl 0 <?>

-- | Get the result of parsing with the input, but without changing the
--   state. No input is consumed.
lookAhead :: ParseT b a -> ParseT b a

-- | Parse with the input, but pretend that no input has been consumed if
--   it fails. This can be used when arbitray lookahead is needed.
try :: ParseT b a -> ParseT b a

-- | Parse with the given parsers, and return the result of the first one
--   to succeed. Implemented with <a>&lt;|&gt;</a>.
choice :: [ParseT b a] -> ParseT b a

-- | Fail if the given parser succeeds
unexpected :: ParseT b a -> ParseT b ()

-- | Fail if the first input fails, or the second succeeds.
notFollowedBy :: ParseT i a -> ParseT i b -> ParseT i a

-- | Parse with the first parser until the second succeeds. The result of
--   the second is thrown away. You can use <a>lookAhead</a> if this is
--   undesireable.
manyTill :: ParseT i a -> ParseT i b -> ParseT i [a]

-- | Parse with the first input, then the third, then the second. Can be
--   used to implement parens and similar parsers.
between :: ParseT i a -> ParseT i b -> ParseT i c -> ParseT i c


-- | A module containing the most basic string parsers. These mostly parse
--   a single character.
module Parser.Char

-- | The string parser type.
type Parser a = ParseT String a

-- | Get one item from the string input, and update the state accordingly.
item :: Parser Char

-- | Succeed if this is the end of input.
eof :: Parser ()

-- | Parse a character satisfying the predicate.
sat :: (Char -> Bool) -> Parser Char

-- | Parse a character satisfying the predicate.
letter :: Parser Char

-- | Parse a character satisfying the predicate.
digit :: Parser Char

-- | Parse a character satisfying the predicate.
alphaNum :: Parser Char

-- | Match the given character.
char :: Char -> Parser Char

-- | Skip whitespace, note that this skips newlines as well.
space :: Parser ()

-- | Skip whitespace, note that this skips newlines as well.
spaces :: Parser ()


-- | A module containing parsers that parse strings.
module Parser.String

-- | Match a given string.
string :: String -> Parser String

-- | Parse with a parser, then ignore trailing whitespace.
lexeme :: Parser a -> Parser a

-- | Parse an integer literal that is not followed by a letter.
intLit :: Parser Integer

-- | Parse a string literal.
strLit :: Parser String

-- | Parse an identifier.
identifier :: Parser String

-- | Parse a given string, and skip trailing whitespace.
symbol :: String -> Parser String

-- | Parse with the given parser, but with surrounding parentheses.
parens :: Parser a -> Parser a

-- | Parse with the given parser, but with surrounding brackets.
brackets :: Parser a -> Parser a

-- | Parse with the given parser, but with surrounding braces.
braces :: Parser a -> Parser a

-- | Parse with the first parser multiple times, separated by the second
--   parser.
--   
--   <pre>
--   parse (identifier `sepBy` (char '|')) "foo|bar|baz"
--   </pre>
--   
--   Or, if you would like to ignore whitespace after the separator
--   
--   <pre>
--   parse (identifier `sepBy` (symbol "|") "foo | bar | baz")
--   </pre>
sepBy :: Parser a -> Parser b -> Parser [a]

-- | Parse multiple times with the given parser, separated by commas.
--   
--   <pre>
--   parse (commaSep intLit) "13,1,5,12"
--   </pre>
commaSep :: Parser a -> Parser [a]

-- | Parse multiple times with a given parser, separated by commas, and
--   surrounded by brackets.
--   
--   <pre>
--   parse (list intLit) "[123,5,1]"
--   </pre>
list :: Parser a -> Parser [a]

-- | Parse multiple times with a given parser, separated by commas, and
--   surrounded by parentheses.
--   
--   <pre>
--   parse (tuple identifier) "(foo, bar, baz)"
--   </pre>
tuple :: Parser a -> Parser [a]

-- | With surrounding braces, parse multiple occurences of the first
--   parser, then a colon, then the second parser. These occurences are
--   separated by commas.
--   
--   <pre>
--   parse (identifier `mapTo` var) "{abc : 123, xyz : 512}"
--   </pre>
mapTo :: Parser a -> Parser b -> Parser [(a, b)]


-- | A module containing functions that let you parse strings or files with
--   the parsers you create.
--   
--   You can also use the test parsers to print the results directly,
--   giving you an easier time seeing the results.
module Parser.Parse

-- | Parse with the parser and return the result.
parse :: Parser a -> String -> Result String a

-- | Parse a given string, and print the result.
parseTest :: Show a => Parser a -> String -> IO ()

-- | Parse a file with a given parser.
parseFile :: Parser a -> FilePath -> IO (Result String a)

-- | Parse a given file, and print the result.
parseFileTest :: Show a => Parser a -> FilePath -> IO ()


-- | The parser module for Lambada
module Lambada.Parser

-- | Parse a Lambada string
lambada :: Parser Expr

-- | The result data type, inspired by <a>either</a>, but made into its own
--   type to redefine the show instance.
data Result b a
Err :: (State b) -> Result b a
Ok :: (a, State b) -> Result b a


-- | A higher level interface for Lambada
module Lambada.Lambada

-- | A function that parses and evaluates a given string
evalLambada :: String -> Either String Expr

-- | A function that parses and evaluates a given string in a context
evalLambada' :: Ctx -> String -> Either String Expr

-- | A function that evaluates an expression
evaluate :: Expr -> Either String Expr

-- | A function that evaluates an expression in a given context
eval :: Ctx -> Expr -> Either String Expr

-- | Parse a Lambada string
lambada :: Parser Expr

-- | Parse with the parser and return the result.
parse :: Parser a -> String -> Result String a

-- | A data type for storing variables and their values
type Ctx = Map String Expr
