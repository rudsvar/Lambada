-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | For more information check out
--   <a>https://rudsvar.github.io/lambada</a>
@package lambada
@version 0.1.0.0


-- | A module that defines Lambada expressions
module Lambada.Expr

-- | The expression data type
data Expr

-- | Integer
EInt :: Integer -> Expr

-- | String
EStr :: String -> Expr

-- | Variable
EVar :: String -> Expr

-- | Let-expression
Let :: String -> Expr -> Expr -> Expr

-- | Lambda abstraction
Abs :: String -> Expr -> Expr

-- | Function application
App :: Expr -> [Expr] -> [Expr] -> Expr
instance GHC.Classes.Eq Lambada.Expr.Expr
instance GHC.Show.Show Lambada.Expr.Expr
instance GHC.Num.Num Lambada.Expr.Expr


-- | A module containing the <a>State</a> data type, which is used in
--   Parser.ParseT to represent the changing state while parsing.
module Parser.State

-- | The state data type It keeps track of the remaining input, the
--   location, whether or not input has been consumed, and the error stack.
data State a
State :: String -> Loc -> Bool -> ParseError -> State a
[inp] :: State a -> String
[loc] :: State a -> Loc
[consumed] :: State a -> Bool
[parseError] :: State a -> ParseError

-- | A data type used to represent an error while parsing. This is used to
--   generate a trace of what a parser expected, what the parser got, and
--   where the error occured.
data ParseError
ParseError :: String -> [Label] -> ParseError
[actual] :: ParseError -> String
[expected] :: ParseError -> [Label]

-- | The location data type. This is used to keep track of the location in
--   the <a>State</a> data type.
data Loc

-- | A label used to explain what was expected when the the
--   <a>ParseError</a> occured.
type Label = String

-- | Add an error to the <a>State</a> stack with the given label.
labelState :: Label -> State a -> State a

-- | Generates a state with the given filepath and input.
defaultState :: FilePath -> String -> State a

-- | Function that edits the location of the <a>State</a>
incCol :: State a -> State a

-- | Function that edits the location of the <a>State</a>
incLine :: State a -> State a

-- | Function that edits the location of the <a>State</a>
resetCol :: State a -> State a

-- | Clear the expected list
clearExpected :: State a -> State a

-- | Update the remaining input in the error
updateError :: State a -> State a
instance GHC.Classes.Eq Parser.State.Loc
instance GHC.Show.Show a => GHC.Show.Show (Parser.State.State a)
instance GHC.Show.Show Parser.State.ParseError
instance GHC.Show.Show Parser.State.Loc


-- | The most general parser type, along with some low level functions used
--   to manipulate the <a>State</a> of the parser.
module Parser.GeneralParser

-- | The parser type, which is imply a function from one state to either a
--   state, or a state along with a result.
newtype GeneralParser b a
P :: (State b -> Either (State b) (a, State b)) -> GeneralParser b a
[runParser] :: GeneralParser b a -> State b -> Either (State b) (a, State b)

-- | The <a>Functor</a> instance of <a>GeneralParser</a>, letting you apply
--   a function to the result of a given parser.

-- | The <a>Applicative</a> instance of <a>GeneralParser</a>, giving us the
--   <a>pure</a> function, which always succeeds with the input as the
--   result, and the <a>&lt;*&gt;</a> operator, which lets you get a
--   function as a result from one parser, and then apply it to the second.

-- | The <a>Alternative</a> instance of <a>GeneralParser</a>, giving us two
--   parsers. The first is the <a>empty</a> parser which always fails. The
--   second is the <a>&lt;|&gt;</a> operator, which first parses with the
--   first argument, and if it fails without consuming any input, parses
--   with the second.

-- | The <a>Monad</a> instance of the <a>GeneralParser</a>, which gives you
--   the <a>return</a> function, which is defined equal to <a>pure</a>, and
--   the <a>&gt;&gt;=</a> (bind) operator, which parses with the first
--   input, and sends the result (if it succeeds) to the function that is
--   the second input.

-- | Get the default implementation from Alternative

-- | A parser that applies the given function to its state.
modifyState :: (State b -> State b) -> GeneralParser b ()

-- | A parser that returns its state.
getState :: GeneralParser b (State b)

-- | A parser that replaces its state with a given one.
setState :: State b -> GeneralParser b ()
instance GHC.Base.Functor (Parser.GeneralParser.GeneralParser b)
instance GHC.Base.Applicative (Parser.GeneralParser.GeneralParser b)
instance GHC.Base.Alternative (Parser.GeneralParser.GeneralParser b)
instance GHC.Base.Monad (Parser.GeneralParser.GeneralParser b)
instance GHC.Base.MonadPlus (Parser.GeneralParser.GeneralParser b)


-- | A module defining a few primitive, general parsers. These can be used
--   for any kind of input.
module Parser.Prim

-- | Label a parser for better error messages.
label :: String -> GeneralParser b a -> GeneralParser b a

-- | The same as <a>label</a>, but with the arguments flipped.
(<?>) :: GeneralParser b a -> String -> GeneralParser b a
infixl 0 <?>

-- | Like label, but do not keep sub-errors, this can be useful to ignore
--   errors that are distracting and not useful.
label' :: String -> GeneralParser b a -> GeneralParser b a

-- | The same as <a>label'</a>, but with the arguments flipped.
(<?!>) :: GeneralParser b a -> String -> GeneralParser b a
infixl 0 <?!>

-- | Get the result of parsing with the input, but without changing the
--   state. No input is consumed.
lookAhead :: GeneralParser b a -> GeneralParser b a

-- | Parse with the input, but pretend that no input has been consumed if
--   it fails. This can be used when arbitrary lookahead is needed.
try :: GeneralParser b a -> GeneralParser b a

-- | Parse with the given parsers, and return the result of the first one
--   to succeed. Implemented with <a>&lt;|&gt;</a>.
choice :: [GeneralParser b a] -> GeneralParser b a

-- | Fail if the given parser succeeds
unexpected :: GeneralParser b a -> GeneralParser b ()

-- | Fail if the first input fails, or the second succeeds.
notFollowedBy :: GeneralParser i a -> GeneralParser i b -> GeneralParser i a

-- | Parse with the first parser until the second succeeds. The result of
--   the second is thrown away. You can use <a>lookAhead</a> if this is
--   undesireable.
manyTill :: GeneralParser i a -> GeneralParser i b -> GeneralParser i [a]

-- | Parse with the first input, then the third, then the second. Can be
--   used to implement parens and similar parsers.
between :: GeneralParser i a -> GeneralParser i b -> GeneralParser i c -> GeneralParser i c


-- | A module containing the most basic string parsers. These mostly parse
--   a single character.
module Parser.Char

-- | The string parser type.
type Parser a = GeneralParser String a

-- | Get one item from the string input, and update the state accordingly.
item :: Parser Char

-- | Succeed if this is the end of input.
eof :: Parser ()

-- | Parse a character satisfying the predicate.
sat :: (Char -> Bool) -> Parser Char

-- | Parse a character satisfying the predicate.
letter :: Parser Char

-- | Parse a character satisfying the predicate.
alpha :: Parser Char

-- | Parse a character satisfying the predicate.
digit :: Parser Char

-- | Parse a character satisfying the predicate.
alphaNum :: Parser Char

-- | Match the given character.
char :: Char -> Parser Char

-- | Match the given character.
notChar :: Char -> Parser Char

-- | Skip whitespace, note that this skips newlines as well.
space :: Parser ()

-- | Skip whitespace, note that this skips newlines as well.
spaces :: Parser ()


-- | A module containing parsers that parse strings.
module Parser.String

-- | Match a given string.
string :: String -> Parser String

-- | Parse with a parser, then ignore trailing whitespace.
lexeme :: Parser a -> Parser a

-- | Parse an integer literal that is not followed by a letter.
intLit :: Parser Integer

-- | Parse a string literal.
strLit :: Parser String

-- | Parse an identifier.
identifier :: Parser String

-- | Parse a given string, and skip trailing whitespace.
word :: String -> Parser String

-- | Parse with the given parser, but with surrounding parentheses.
parens :: Parser a -> Parser a

-- | Parse with the given parser, but with surrounding brackets.
brackets :: Parser a -> Parser a

-- | Parse with the given parser, but with surrounding braces.
braces :: Parser a -> Parser a

-- | Parse with the first parser multiple times, separated by the second
--   parser.
--   
--   <pre>
--   parse (identifier `sepBy` (char '|')) "foo|bar|baz"
--   </pre>
--   
--   Or, if you would like to ignore whitespace after the separator
--   
--   <pre>
--   parse (identifier `sepBy` (word "|") "foo | bar | baz")
--   </pre>
sepBy :: Parser a -> Parser b -> Parser [a]

-- | Parse multiple times with the given parser, separated by commas.
--   
--   <pre>
--   parse (commaSep intLit) "13,1,5,12"
--   </pre>
commaSep :: Parser a -> Parser [a]

-- | Parse multiple times with a given parser, separated by commas, and
--   surrounded by brackets.
--   
--   <pre>
--   parse (list intLit) "[123,5,1]"
--   </pre>
list :: Parser a -> Parser [a]

-- | Parse multiple times with a given parser, separated by commas, and
--   surrounded by parentheses.
--   
--   <pre>
--   parse (tuple identifier) "(foo, bar, baz)"
--   </pre>
tuple :: Parser a -> Parser [a]

-- | Parse multiple times with a given parser, separated by commas, and
--   surrounded by parentheses.
--   
--   <pre>
--   parse (set identifier) "{foo, bar, baz}"
--   </pre>
set :: Parser a -> Parser [a]

-- | With surrounding braces, parse multiple occurences of the first
--   parser, then a colon, then the second parser. These occurences are
--   separated by commas.
--   
--   <pre>
--   parse (identifier `mapTo` var) "{abc : 123, xyz : 512}"
--   </pre>
mapTo :: Parser a -> Parser b -> Parser [(a, b)]


-- | A module containing functions that let you parse strings or files with
--   the parsers you create.
--   
--   You can also use the test parsers to print the results directly,
--   giving you an easier time seeing the results.
module Parser.Parse

-- | Parse with the parser and return the result.
parse :: Parser a -> String -> Either String a

-- | Parse a given string, and print the result.
parseTest :: Show a => Parser a -> String -> IO ()

-- | Parse a file with a given parser.
parseFile :: Parser a -> FilePath -> IO (Either String a)

-- | Parse a given file, and print the result.
parseFileTest :: Show a => Parser a -> FilePath -> IO ()


-- | Automatically generate some parsers for a language.
module Parser.Generator

-- | A table of operator symbols and their constructors.
type OpTable a = [[(String, a -> a -> a)]]

-- | Information about the language. Used to generate parsers.
data LangInfo a
LangInfo :: OpTable a -> [String] -> (Integer -> a) -> (String -> a) -> Parser a -> LangInfo a
[opTable] :: LangInfo a -> OpTable a
[keywords] :: LangInfo a -> [String]
[intConstr] :: LangInfo a -> Integer -> a
[varConstr] :: LangInfo a -> String -> a
[bottomParser] :: LangInfo a -> Parser a

-- | A data type containing the generated parsers.
data GeneratedParsers a
GeneratedParsers :: Parser a -> Parser a -> Parser a -> GeneratedParsers a
[expression] :: GeneratedParsers a -> Parser a
[integer] :: GeneratedParsers a -> Parser a
[variable] :: GeneratedParsers a -> Parser a

-- | Generate parsers using the language information.
generateParsers :: LangInfo a -> GeneratedParsers a


-- | The parser module for Lambada
module Lambada.Parser

-- | Parse a Lambada string
lambada :: Parser Expr

-- | A collection of information about a language
data LangInfo
LangInfo :: [String] -> [String] -> LangInfo
[keywords] :: LangInfo -> [String]
[operators] :: LangInfo -> [String]

-- | Language information for Lambada
lambadaInfo :: LangInfo

-- | Parse a word with lookahead
keyword :: String -> Parser String

-- | Parse one of the operators
operator :: Parser String

-- | Parse an expression
expr :: Parser Expr

-- | Parse anything but application
nonApp :: Parser Expr

-- | Parse a let expression
letExpr :: Parser Expr

-- | Parse a variable
var :: Parser Expr

-- | Parse a lambda abstraction
abstraction :: Parser Expr

-- | Parse an application
application :: Parser Expr


-- | An environment type that represents a map of variables and their
--   values.
module Types.Env

-- | The environment type
data Env

-- | An empty environment
emptyEnv :: Env

-- | Insert a key and a value into the environment
insertEnv :: String -> Expr -> Env -> Env

-- | Look up the value of a key in the environment
lookupEnv :: String -> Env -> Either String Expr


-- | A module for evaluating expressions in Lambada
module Lambada.Eval

-- | Evaluate an expression
eval :: Expr -> Either String Expr

-- | Evaluate an expression in a given environment
evalWith :: Env -> Expr -> Either String Expr


-- | A higher level interface for Lambada
module Lambada.Lambada

-- | Parse and evaluate a given string and print the result.
evalLambadaTest :: String -> IO ()

-- | Parse and evaluate a given string in an environment and print the
--   result.
evalLambadaWithTest :: Env -> String -> IO ()

-- | Parse and evaluate a given string.
evalLambada :: String -> Either String Expr

-- | Parse and evaluate a given string in an environment.
evalLambadaWith :: Env -> String -> Either String Expr

-- | The environment type
data Env

-- | An empty environment
emptyEnv :: Env

-- | Insert a key and a value into the environment
insertEnv :: String -> Expr -> Env -> Env

-- | Look up the value of a key in the environment
lookupEnv :: String -> Env -> Either String Expr

-- | The expression data type
data Expr
